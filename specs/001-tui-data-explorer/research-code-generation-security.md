# Research: Safe Code Generation and Execution for Narwhals Operations

**Date**: 2026-01-09  
**Context**: Building a TUI where users fill out forms to generate narwhals dataframe operations stored as executable code strings.

## Executive Summary

### Decision: **Use direct function calls instead of eval/exec**

**Rationale**: After analyzing the current implementation and security best practices, the safest approach is to avoid `eval()` entirely and use direct function calls with validated parameters.

### Current State Analysis

The codebase currently uses `eval()` with restricted builtins in `src/kittiwake/models/operations.py:51`:

```python
namespace = {"df": df, "nw": nw}
result = eval(self.code, {"__builtins__": {}}, namespace)
```

While this restricts the global namespace, it still allows:
- Arbitrary attribute access (e.g., `df.__class__.__bases__`)
- Complex expressions that could cause performance issues
- Potential for code injection if column names aren't properly escaped

## Research Questions & Answers

### 1. Is using `eval()` safe if all code is generated by the application?

**Answer**: **No, not completely safe even with restricted builtins.**

**Risks**:
- **Column name injection**: If column names contain special characters or are maliciously crafted, they could break out of string quotes
- **Attribute access**: Even with `{"__builtins__": {}}`, code can still access attributes like `__class__`, `__bases__`, etc.
- **Performance attacks**: Complex expressions like `nw.col('x') > nw.col('y') > nw.col('z')...` (repeated thousands of times) could cause performance issues
- **AST complexity**: Very large generated expressions could cause stack overflow

**Example vulnerability**:
```python
# If column name is: "); df.__class__.__bases__[0].__subclasses__(); ("
code = f'df.filter(nw.col("{column_name}") > 25)'
# Results in: df.filter(nw.col(""); df.__class__.__bases__[0].__subclasses__(); ("") > 25)
```

### 2. What's the best approach for executing generated narwhals code?

**Answer**: **Use a builder pattern with direct function calls, not string-based code generation.**

**Recommended approach**:

```python
class OperationBuilder:
    """Build and execute narwhals operations without eval()."""
    
    @staticmethod
    def build_filter(column: str, operator: str, value: Any) -> Callable:
        """Build a filter operation."""
        # Validate inputs
        if not isinstance(column, str) or not column:
            raise ValueError("Column must be a non-empty string")
        if operator not in ['==', '!=', '>', '<', '>=', '<=', 'contains']:
            raise ValueError(f"Invalid operator: {operator}")
        
        # Return a callable that applies the operation
        def apply_filter(df: nw.LazyFrame) -> nw.LazyFrame:
            col_expr = nw.col(column)
            
            if operator == 'contains':
                if not isinstance(value, str):
                    raise ValueError("contains operator requires string value")
                return df.filter(col_expr.str.contains(value))
            
            # Map operators to expressions
            ops = {
                '==': col_expr == value,
                '!=': col_expr != value,
                '>': col_expr > value,
                '<': col_expr < value,
                '>=': col_expr >= value,
                '<=': col_expr <= value,
            }
            return df.filter(ops[operator])
        
        return apply_filter
    
    @staticmethod
    def build_aggregate(column: str, functions: list[str], group_by: list[str] = None) -> Callable:
        """Build an aggregation operation."""
        # Validate inputs
        valid_funcs = {'count', 'sum', 'mean', 'median', 'min', 'max', 'std', 'var', 'nunique'}
        if not all(f in valid_funcs for f in functions):
            raise ValueError(f"Invalid aggregation function")
        
        def apply_aggregate(df: nw.LazyFrame) -> nw.LazyFrame:
            col_expr = nw.col(column)
            
            # Build aggregation expressions
            agg_exprs = []
            for func in functions:
                expr = getattr(col_expr, func)()
                agg_exprs.append(expr.alias(f"{column}_{func}"))
            
            if group_by:
                return df.group_by(group_by).agg(agg_exprs)
            else:
                return df.select(agg_exprs)
        
        return apply_aggregate
```

**Advantages**:
- No eval/exec needed - direct Python function calls
- Type-safe parameters with validation
- Clear error messages
- Easier to test and debug
- No risk of code injection
- Better IDE support and autocomplete

### 3. How to handle escaping/quoting of user input values?

**Answer**: **Don't use string templates - use direct parameter passing.**

**Current problematic approach** (in `filter_modal.py:147-158`):
```python
# UNSAFE - vulnerable to injection
code = f'df.filter(nw.col("{column}").str.contains("{value}"))'
```

**Recommended approach**:
```python
# SAFE - no string interpolation
operation_callable = OperationBuilder.build_filter(column, 'contains', value)
# Store parameters, not code string
params = {"column": column, "operator": "contains", "value": value}
```

If you **must** generate code strings (for display/export purposes):
```python
def safe_repr(value: Any) -> str:
    """Safely represent a value as Python code."""
    if isinstance(value, str):
        # Use repr() which properly escapes quotes
        return repr(value)
    elif isinstance(value, (int, float, bool, type(None))):
        return repr(value)
    else:
        raise ValueError(f"Unsupported value type: {type(value)}")

# Generate safe code string
code = f"df.filter(nw.col({repr(column)}) {operator} {safe_repr(value)})"
```

### 4. How to validate generated code before execution?

**Answer**: **Use parameter validation and AST parsing for code strings.**

**Validation strategy**:

```python
import ast
from typing import Any, Tuple

class OperationValidator:
    """Validate operation parameters and code."""
    
    SAFE_NAMES = {'df', 'nw', 'col'}  # Allowed name references
    SAFE_ATTRIBUTES = {'filter', 'group_by', 'agg', 'select', 'sort', 'str', 'contains'}
    
    @staticmethod
    def validate_params(operation_type: str, params: dict) -> Tuple[bool, str]:
        """Validate operation parameters."""
        validators = {
            'filter': OperationValidator._validate_filter_params,
            'aggregate': OperationValidator._validate_aggregate_params,
            'select': OperationValidator._validate_select_params,
        }
        
        if operation_type not in validators:
            return False, f"Unknown operation type: {operation_type}"
        
        return validators[operation_type](params)
    
    @staticmethod
    def _validate_filter_params(params: dict) -> Tuple[bool, str]:
        """Validate filter parameters."""
        required = ['column', 'operator', 'value']
        if not all(k in params for k in required):
            return False, f"Missing required params: {required}"
        
        if not isinstance(params['column'], str):
            return False, "Column must be a string"
        
        valid_ops = ['==', '!=', '>', '<', '>=', '<=', 'contains']
        if params['operator'] not in valid_ops:
            return False, f"Invalid operator: {params['operator']}"
        
        # Validate value type based on operator
        if params['operator'] == 'contains' and not isinstance(params['value'], str):
            return False, "contains operator requires string value"
        
        return True, ""
    
    @staticmethod
    def validate_code_string(code: str) -> Tuple[bool, str]:
        """Validate generated code string using AST parsing."""
        try:
            tree = ast.parse(code, mode='eval')
        except SyntaxError as e:
            return False, f"Syntax error: {e}"
        
        # Check for unsafe operations
        for node in ast.walk(tree):
            # Disallow imports
            if isinstance(node, (ast.Import, ast.ImportFrom)):
                return False, "Import statements not allowed"
            
            # Disallow function calls except whitelisted ones
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Attribute):
                    # Allow method calls on df/nw objects
                    pass
                elif isinstance(node.func, ast.Name):
                    # Only allow specific function names
                    if node.func.id not in {'col'}:
                        return False, f"Function call not allowed: {node.func.id}"
            
            # Disallow certain attribute access
            if isinstance(node, ast.Attribute):
                if node.attr.startswith('_'):
                    return False, f"Private attribute access not allowed: {node.attr}"
        
        return True, ""
```

### 5. Best practices for error handling when generated code fails?

**Answer**: **Use structured exceptions with context preservation.**

```python
class OperationError(Exception):
    """Base exception for operation errors."""
    def __init__(self, message: str, operation: 'Operation', cause: Exception = None):
        super().__init__(message)
        self.operation = operation
        self.cause = cause

class OperationValidationError(OperationError):
    """Raised when operation parameters are invalid."""
    pass

class OperationExecutionError(OperationError):
    """Raised when operation execution fails."""
    pass

def apply_operation_safe(df: nw.LazyFrame, operation: Operation) -> Tuple[nw.LazyFrame | None, str | None]:
    """
    Safely apply operation with comprehensive error handling.
    
    Returns:
        (result_df, error_message) tuple
    """
    try:
        # Validate before execution
        is_valid, error_msg = OperationValidator.validate_params(
            operation.operation_type, 
            operation.params
        )
        if not is_valid:
            return None, f"Validation failed: {error_msg}"
        
        # Build and execute operation
        operation_func = OperationBuilder.build_operation(
            operation.operation_type,
            operation.params
        )
        result = operation_func(df)
        
        return result, None
        
    except KeyError as e:
        # Column doesn't exist
        return None, f"Column not found: {e}"
    
    except TypeError as e:
        # Type mismatch (e.g., comparing string to number)
        return None, f"Type error: {e}. Check column types and values."
    
    except ValueError as e:
        # Invalid value
        return None, f"Invalid value: {e}"
    
    except Exception as e:
        # Catch-all for unexpected errors
        return None, f"Operation failed: {type(e).__name__}: {e}"
```

### 6. Performance considerations for repeatedly executing narwhals operations?

**Answer**: **Leverage lazy evaluation and operation chaining.**

```python
class OperationChain:
    """Efficiently chain multiple operations on lazy frames."""
    
    def __init__(self, df: nw.LazyFrame):
        self.df = df
        self.operations: list[Callable] = []
    
    def add_operation(self, operation: Operation):
        """Add operation to chain without executing."""
        op_func = OperationBuilder.build_operation(
            operation.operation_type,
            operation.params
        )
        self.operations.append(op_func)
    
    def execute(self) -> nw.DataFrame:
        """Execute all operations in one go."""
        result = self.df
        for op_func in self.operations:
            result = op_func(result)
        # Only collect at the end
        return result.collect()
    
    def preview(self, n: int = 10) -> nw.DataFrame:
        """Preview first n rows efficiently."""
        result = self.df
        for op_func in self.operations:
            result = op_func(result)
        return result.head(n).collect()
```

**Performance best practices**:
1. **Use lazy evaluation**: Chain operations on `LazyFrame`, collect only when needed
2. **Limit preview size**: Use `.head(n)` for UI previews
3. **Cache results**: Store `.collect()` results for operations that won't change
4. **Validate early**: Check column existence before executing expensive operations
5. **Monitor complexity**: Set limits on number of chained operations

## Implementation Pattern

### Recommended Architecture

```python
# 1. User fills out form
form_data = {
    "column": "age",
    "operator": ">",
    "value": 25
}

# 2. Create operation with validated parameters
operation = Operation(
    operation_type="filter",
    params=form_data,
    display=f"Filter: {form_data['column']} {form_data['operator']} {form_data['value']}"
)

# 3. Validate operation
is_valid, error = OperationValidator.validate_params(
    operation.operation_type,
    operation.params
)

# 4. Build executable function (not code string)
operation_func = OperationBuilder.build_filter(**form_data)

# 5. Execute operation
result_df, error = apply_operation_safe(df, operation)

# 6. (Optional) Generate code string for display/export
code_string = OperationCodeGenerator.generate_code(operation)
# e.g., "df.filter(nw.col('age') > 25)"
```

### Code String Generation (for display/export only)

```python
class OperationCodeGenerator:
    """Generate narwhals code strings for display/export purposes."""
    
    @staticmethod
    def generate_code(operation: Operation) -> str:
        """Generate code string from operation parameters."""
        generators = {
            'filter': OperationCodeGenerator._generate_filter_code,
            'aggregate': OperationCodeGenerator._generate_aggregate_code,
            'select': OperationCodeGenerator._generate_select_code,
        }
        
        return generators[operation.operation_type](operation.params)
    
    @staticmethod
    def _generate_filter_code(params: dict) -> str:
        """Generate filter code string."""
        column = repr(params['column'])  # Safe escaping
        operator = params['operator']
        value = repr(params['value'])  # Safe escaping
        
        if operator == 'contains':
            return f"df.filter(nw.col({column}).str.contains({value}))"
        else:
            return f"df.filter(nw.col({column}) {operator} {value})"
```

## Alternatives Considered

### Alternative 1: AST-based execution (compile + exec)

```python
def execute_with_ast(code: str, df: nw.LazyFrame) -> nw.LazyFrame:
    """Execute code using AST compilation."""
    tree = ast.parse(code, mode='eval')
    # Validate AST structure
    compiled = compile(tree, '<string>', 'eval')
    namespace = {'df': df, 'nw': nw}
    return eval(compiled, {"__builtins__": {}}, namespace)
```

**Pros**: Slightly more flexible than direct function calls
**Cons**: Still vulnerable to attribute access attacks, more complex, harder to debug

### Alternative 2: Restricted Python execution (RestrictedPython library)

```python
from RestrictedPython import compile_restricted

def execute_restricted(code: str, df: nw.LazyFrame) -> nw.LazyFrame:
    """Execute code in restricted environment."""
    compiled = compile_restricted(code, '<string>', 'eval')
    namespace = {'df': df, 'nw': nw}
    return eval(compiled, namespace)
```

**Pros**: More sophisticated sandboxing
**Cons**: External dependency, adds complexity, may have undiscovered vulnerabilities

### Alternative 3: JSON-based operation specification

```python
operation_spec = {
    "type": "filter",
    "column": "age",
    "operator": ">",
    "value": 25
}
# Interpreter translates JSON to operations
```

**Pros**: Language-agnostic, very safe
**Cons**: Limited expressiveness, requires complex interpreter

## Conclusion

**Use direct function calls with builder pattern instead of eval/exec.**

This provides:
- ✅ **Security**: No code injection risks
- ✅ **Maintainability**: Clear, testable code
- ✅ **Performance**: Efficient lazy evaluation
- ✅ **Developer experience**: Type hints, IDE support
- ✅ **Flexibility**: Easy to extend with new operation types

Store operation parameters in the database, not code strings. Generate code strings only when needed for display or export purposes using safe `repr()` escaping.

## Migration Path

1. **Phase 1**: Add `OperationBuilder` class alongside current `eval()` implementation
2. **Phase 2**: Update modals to use builder pattern for new operations
3. **Phase 3**: Add migration to convert existing stored operations
4. **Phase 4**: Remove `eval()` from codebase
5. **Phase 5**: Add code string generation for export features

## References

- Python `eval()` documentation: https://docs.python.org/3/library/functions.html#eval
- Python AST module: https://docs.python.org/3/library/ast.html
- Narwhals documentation: https://narwhals-dev.github.io/narwhals/
- OWASP Code Injection: https://owasp.org/www-community/attacks/Code_Injection
